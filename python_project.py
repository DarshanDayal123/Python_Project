# -*- coding: utf-8 -*-
"""Python_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YZhMSha4IEFZIDzMN3HERGcH6Yl2dMxx
"""

pip install yfinance

"""**Data Collection**"""

import yfinance as yf
import pandas as pd

tickers = ['BTC-USD', 'ETH-USD', 'SOL1-USD']  # Tickers for Bitcoin, Ethereum, and Solana
start_date = '2021-01-01'
end_date = '2022-01-01'
crypto_data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']



# Fetch historical data for Bitcoin prices from Yahoo Finance
btc_data = yf.download('BTC-USD', start='2010-01-01', end='2024-01-01')

# Append the new data to your existing dataset
crypto_data_extended = pd.concat([crypto_data, btc_data['Close']], axis=1)


crypto_data

"""**Data Preprocessing**"""

# Drop rows with missing values
crypto_data.dropna(inplace=True)



# Convert the data into a suitable format (DataFrame)
crypto_data.reset_index(inplace=True)

# Example code to clean Bitcoin price predictions

import pandas as pd

# Assuming the data is stored in a DataFrame named crypto_data
crypto_data = pd.DataFrame({
    'BTC-USD': [7200.174316, 6985.470215, 7344.884277, 7410.656738, 7411.317383, 42520.402344, 43442.855469, 42627.855469, 42099.402344, 42156.902344],
    'ETH-USD': [130.802002, 127.410179, 134.171707, 135.069366, 136.276779, 2231.465332, 2378.739990, 2347.566162, 2300.690674, 2292.065430],
    'SOL1-USD': [3.21, 3.17, 3.25, 3.28, 3.32, 20.05, 21.18, 20.75, 20.32, 20.21]  # Example Solana prices
})

# Print the first few rows of the DataFrame
print(crypto_data.head())

print(crypto_data.shape)
# print(rf_model_btc.feature_importances_.shape)

"""***Time series plots of Bitcoin and Ethereum prices:***"""

import matplotlib.pyplot as plt

# Time series plots
plt.figure(figsize=(10, 6))
plt.plot(crypto_data.index, crypto_data['BTC-USD'], label='Bitcoin')
plt.plot(crypto_data.index, crypto_data['ETH-USD'], label='Ethereum')
plt.plot(crypto_data.index, crypto_data['SOL1-USD'], label='Solana')  # Adding Solana data
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('Time Series Plot of Bitcoin, Ethereum, and Solana Prices')
plt.legend()
plt.show()

""" ***Histograms or density plots showing the distribution of cryptocurrency prices:***"""

plt.figure(figsize=(10, 6))
plt.hist(crypto_data['BTC-USD'], bins=30, alpha=0.5, label='Bitcoin')
plt.hist(crypto_data['ETH-USD'], bins=30, alpha=0.5, label='Ethereum')
plt.hist(crypto_data['SOL1-USD'], bins=30, alpha=0.5, label='Solana')  # Adding Solana data
plt.xlabel('Price (USD)')
plt.ylabel('Frequency')
plt.title('Distribution of Bitcoin, Ethereum, and Solana Prices')
plt.legend()
plt.show()

"""**Feature Engineering**"""

# Calculate moving averages for Solana
crypto_data['MA_7_SOL1'] = crypto_data['SOL1-USD'].rolling(window=7).mean()
crypto_data['MA_30_SOL1'] = crypto_data['SOL1-USD'].rolling(window=30).mean()

# Calculate volatility for Solana
crypto_data['Volatility_7_SOL1'] = crypto_data['SOL1-USD'].pct_change().rolling(window=7).std()
crypto_data['Volatility_30_SOL1'] = crypto_data['SOL1-USD'].pct_change().rolling(window=30).std()

# Add lagged values of the target variable (price) as features for Solana
crypto_data['Lagged_Price_1_SOL1'] = crypto_data['SOL1-USD'].shift(1)
crypto_data['Lagged_Price_3_SOL1'] = crypto_data['SOL1-USD'].shift(3)
crypto_data['Lagged_Price_7_SOL1'] = crypto_data['SOL1-USD'].shift(7)

# Print the first few rows of the DataFrame to verify the new features
print(crypto_data.head())

print(crypto_data.shape)

"""** Line plots of moving averages and volatility measures over time**"""

# Line plots of moving averages and volatility
plt.figure(figsize=(10, 6))
plt.plot(crypto_data.index, crypto_data['MA_7_BTC'], label='Bitcoin (7-day MA)', linestyle='--')
plt.plot(crypto_data.index, crypto_data['MA_30_BTC'], label='Bitcoin (30-day MA)', linestyle='-')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('Moving Averages of Bitcoin Prices')
plt.legend()
plt.show()

"""**Corelation**"""

# Calculate correlation matrix
correlation_matrix = crypto_data.corr()

# Plot correlation matrix
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix of Cryptocurrencies')
plt.show()

"""***Correlation matrices and heatmaps***"""

# Correlation matrix and heatmap for Solana
correlation_matrix_sol1 = crypto_data[['BTC-USD', 'ETH-USD', 'SOL1-USD']].corr()
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix_sol1, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap between Bitcoin, Ethereum, and Solana')
plt.show()

"""**Machine Learning Model**"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.impute import SimpleImputer

# Assuming 'crypto_data' contains the features and target variables
print(crypto_data)
print(crypto_data.shape)

# Split the data into features (X) and target variables (y)
X = crypto_data.drop(['BTC-USD', 'ETH-USD', 'SOL1-USD'], axis=1)  # Features
y_btc = crypto_data['BTC-USD']  # Target variable for Bitcoin
y_eth = crypto_data['ETH-USD']  # Target variable for Ethereum
y_sol1 = crypto_data['SOL1-USD']  # Target variable for Solana

# Split the data into training and testing sets for Bitcoin, Ethereum, and Solana
X_train_btc, X_test_btc, y_train_btc, y_test_btc = train_test_split(X, y_btc, test_size=0.2, random_state=42)
X_train_eth, X_test_eth, y_train_eth, y_test_eth = train_test_split(X, y_eth, test_size=0.2, random_state=42)
X_train_sol1, X_test_sol1, y_train_sol1, y_test_sol1 = train_test_split(X, y_sol1, test_size=0.2, random_state=42)

# Impute missing values in the features using mean imputation
imputer = SimpleImputer(strategy='mean')

# Impute missing values for Bitcoin training and testing data
X_train_btc_imputed = imputer.fit_transform(X_train_btc)
X_test_btc_imputed = imputer.transform(X_test_btc)

# Impute missing values for Ethereum training and testing data
X_train_eth_imputed = imputer.fit_transform(X_train_eth)
X_test_eth_imputed = imputer.transform(X_test_eth)

# Impute missing values for Solana training and testing data
X_train_sol1_imputed = imputer.fit_transform(X_train_sol1)
X_test_sol1_imputed = imputer.transform(X_test_sol1)

# Train the Random Forest model for Bitcoin
rf_model_btc = RandomForestRegressor(random_state=42)
rf_model_btc.fit(X_train_btc_imputed, y_train_btc)

# Evaluate model performance for Bitcoin
y_pred_btc = rf_model_btc.predict(X_test_btc_imputed)
mse_btc = mean_squared_error(y_test_btc, y_pred_btc)
print('Mean Squared Error (Bitcoin):', mse_btc)

# Train the Random Forest model for Ethereum
rf_model_eth = RandomForestRegressor(random_state=42)
rf_model_eth.fit(X_train_eth_imputed, y_train_eth)

# Evaluate model performance for Ethereum
y_pred_eth = rf_model_eth.predict(X_test_eth_imputed)
mse_eth = mean_squared_error(y_test_eth, y_pred_eth)
print('Mean Squared Error (Ethereum):', mse_eth)

# Train the Random Forest model for Solana
rf_model_sol1 = RandomForestRegressor(random_state=42)
rf_model_sol1.fit(X_train_sol1_imputed, y_train_sol1)

# Evaluate model performance for Solana
y_pred_sol1 = rf_model_sol1.predict(X_test_sol1_imputed)
mse_sol1 = mean_squared_error(y_test_sol1, y_pred_sol1)
print('Mean Squared Error (Solana):', mse_sol1)

# Predictions for Bitcoin
btc_predictions = rf_model_btc.predict(X_test_btc_imputed)

# Predictions for Ethereum
eth_predictions = rf_model_eth.predict(X_test_eth_imputed)

# Predictions for Solana
sol1_predictions = rf_model_sol1.predict(X_test_sol1_imputed)

"""**Prediction and Visualization**

***Scatter plots of actual vs. predicted prices***
"""

# Scatter plots of actual vs. predicted prices
plt.figure(figsize=(10, 6))
plt.scatter(y_test_btc, y_pred_btc, alpha=0.5)
plt.xlabel('Actual Price (USD)')
plt.ylabel('Predicted Price (USD)')
plt.title('Actual vs. Predicted Bitcoin Prices')
plt.show()

"""***Residual plots***"""

# Residual plots
plt.figure(figsize=(10, 6))
plt.scatter(y_pred_btc, y_test_btc - y_pred_btc, alpha=0.5)
plt.xlabel('Predicted Price (USD)')
plt.ylabel('Residuals')
plt.title('Residual Plot for Bitcoin Price Prediction')
plt.axhline(y=0, color='r', linestyle='--')
plt.show()

"""***Trend lines showing long-term price trends***"""

# Trend lines showing long-term price trends for Bitcoin, Ethereum, and Solana
plt.figure(figsize=(10, 6))
plt.plot(crypto_data.index, crypto_data['BTC-USD'], label='Bitcoin')
plt.plot(crypto_data.index, crypto_data['ETH-USD'], label='Ethereum')
plt.plot(crypto_data.index, crypto_data['SOL1-USD'], label='Solana')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.title('Long-Term Price Trends for Bitcoin, Ethereum, and Solana')
plt.legend()
plt.show()

"""***Error bars or confidence intervals***"""

import numpy as np
# Error bars or confidence intervals
# Assuming 'y_test_btc' and 'y_pred_btc' are arrays of actual and predicted prices
# Calculate standard deviation of residuals as a measure of uncertainty
std_dev = np.std(y_test_btc - y_pred_btc)
plt.figure(figsize=(10, 6))
plt.errorbar(range(len(y_test_btc)), y_pred_btc, yerr=std_dev, fmt='o', alpha=0.5)
plt.xlabel('Sample Index')
plt.ylabel('Predicted Price (USD)')
plt.title('Predicted Bitcoin Prices with Error Bars')
plt.show()

"""***Box plots or violin plots comparing the distribution of actual and predicted prices***"""

# Box plots or violin plots
plt.figure(figsize=(10, 6))
plt.boxplot([y_test_btc, y_pred_btc], labels=['Actual Price', 'Predicted Price'])
plt.ylabel('Price (USD)')
plt.title('Comparison of Actual and Predicted Bitcoin Prices')
plt.show()

"""***Visualizations of feature importance***"""

import pandas as pd
import matplotlib.pyplot as plt


# Plot actual vs. predicted prices for Bitcoin
plt.figure(figsize=(10, 6))
plt.plot(y_test_btc, label='Actual BTC Price', color='blue')
plt.plot(btc_predictions, label='Predicted BTC Price', color='red')
plt.title('Actual vs. Predicted Bitcoin Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

# Plot actual vs. predicted prices for Ethereum
plt.figure(figsize=(10, 6))
plt.plot(y_test_eth, label='Actual ETH Price', color='blue')
plt.plot(eth_predictions, label='Predicted ETH Price', color='red')
plt.title('Actual vs. Predicted Ethereum Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

# Plot actual vs. predicted prices for Solana
plt.figure(figsize=(10, 6))
plt.plot(y_test_sol1, label='Actual Solana Price', color='blue')
plt.plot(sol1_predictions, label='Predicted Solana Price', color='red')
plt.title('Actual vs. Predicted Solana Prices')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# Plot predictions vs actual prices for Bitcoin
plt.figure(figsize=(10, 6))
plt.plot(y_test_btc.index, y_test_btc, label='Actual Price', color='blue')
plt.plot(y_test_btc.index, btc_predictions, label='Predicted Price', color='red')
plt.title('Bitcoin Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid(True)
plt.show()

# Plot predictions vs actual prices for Ethereum
plt.figure(figsize=(10, 6))
plt.plot(y_test_eth.index, y_test_eth, label='Actual Price', color='blue')
plt.plot(y_test_eth.index, eth_predictions, label='Predicted Price', color='red')
plt.title('Ethereum Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid(True)
plt.show()

# Plot predictions vs actual prices for Solana
plt.figure(figsize=(10, 6))
plt.plot(y_test_sol1.index, y_test_sol1, label='Actual Price', color='blue')
plt.plot(y_test_sol1.index, sol1_predictions, label='Predicted Price', color='red')
plt.title('Solana Price Prediction')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid(True)
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

# Load data for Bitcoin, Ethereum, and Solana from Yahoo Finance
tickers = ['BTC-USD', 'ETH-USD', 'SOL1-USD']
start_date = '2017-06-28'
end_date = '2022-01-01'
crypto_data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']

# Use Bitcoin data for this example
df = crypto_data['BTC-USD'].to_frame()
df.reset_index(inplace=True)
df.columns = ['datetime', 'last']

# Normalize the data
dataset = df['last'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
dataset = scaler.fit_transform(dataset)

# Split the data into training and testing sets
train_size = int(len(dataset) * 0.67)
test_size = len(dataset) - train_size
train, test = dataset[0:train_size, :], dataset[train_size:len(dataset), :]

# Convert data to input-output pairs
def create_dataset(dataset, look_back=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back - 1):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

look_back = 10
trainX, trainY = create_dataset(train, look_back=look_back)
testX, testY = create_dataset(test, look_back=look_back)

# Reshape input to be [samples, time steps, features]
trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))
testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))

# Build and train the LSTM model
model = Sequential()
model.add(LSTM(4, input_shape=(1, look_back)))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(trainX, trainY, epochs=100, batch_size=256, verbose=2)

# Make predictions
trainPredict = model.predict(trainX)
testPredict = model.predict(testX)

# Invert predictions
trainPredict = scaler.inverse_transform(trainPredict)
trainY = scaler.inverse_transform([trainY])
testPredict = scaler.inverse_transform(testPredict)
testY = scaler.inverse_transform([testY])

# Calculate root mean squared error
trainScore = math.sqrt(mean_squared_error(trainY[0], trainPredict[:, 0]))
print('Train Score: %.2f RMSE' % trainScore)
testScore = math.sqrt(mean_squared_error(testY[0], testPredict[:, 0]))
print('Test Score: %.2f RMSE' % testScore)

# Shift train predictions for plotting
trainPredictPlot = np.empty_like(dataset)
trainPredictPlot[:, :] = np.nan
trainPredictPlot[look_back:len(trainPredict) + look_back, :] = trainPredict

# Shift test predictions for plotting
testPredictPlot = np.empty_like(dataset)
testPredictPlot[:, :] = np.nan
testPredictPlot[len(trainPredict) + (look_back * 2) + 1:len(dataset) - 1, :] = testPredict

# Plot actual vs predicted prices
plt.figure(figsize=(12, 6))
plt.plot(df['last'], label='Actual')
plt.plot(pd.DataFrame(trainPredictPlot, columns=["close"], index=df.index).close, label='Training')
plt.plot(pd.DataFrame(testPredictPlot, columns=["close"], index=df.index).close, label='Testing')
plt.legend(loc='best')
plt.show()

# Use Ethereum data for this example
df = crypto_data['ETH-USD'].to_frame()  # Change 'BTC-USD' to 'ETH-USD'
df.reset_index(inplace=True)
df.columns = ['datetime', 'last']

# Normalize the data
dataset = df['last'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
dataset = scaler.fit_transform(dataset)

# Split the data into training and testing sets
train_size = int(len(dataset) * 0.67)
test_size = len(dataset) - train_size
train, test = dataset[0:train_size, :], dataset[train_size:len(dataset), :]

# Convert data to input-output pairs
def create_dataset(dataset, look_back=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back - 1):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

look_back = 10
trainX, trainY = create_dataset(train, look_back=look_back)
testX, testY = create_dataset(test, look_back=look_back)

# Reshape input to be [samples, time steps, features]
trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))
testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))

# Build and train the LSTM model
model = Sequential()
model.add(LSTM(4, input_shape=(1, look_back)))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(trainX, trainY, epochs=100, batch_size=256, verbose=2)

# Make predictions
trainPredict = model.predict(trainX)
testPredict = model.predict(testX)

# Invert predictions
trainPredict = scaler.inverse_transform(trainPredict)
trainY = scaler.inverse_transform([trainY])
testPredict = scaler.inverse_transform(testPredict)
testY = scaler.inverse_transform([testY])

# Calculate root mean squared error
trainScore = math.sqrt(mean_squared_error(trainY[0], trainPredict[:, 0]))
print('Train Score: %.2f RMSE' % trainScore)
testScore = math.sqrt(mean_squared_error(testY[0], testPredict[:, 0]))
print('Test Score: %.2f RMSE' % testScore)

# Shift train predictions for plotting
trainPredictPlot = np.empty_like(dataset)
trainPredictPlot[:, :] = np.nan
trainPredictPlot[look_back:len(trainPredict) + look_back, :] = trainPredict

# Shift test predictions for plotting
testPredictPlot = np.empty_like(dataset)
testPredictPlot[:, :] = np.nan
testPredictPlot[len(trainPredict) + (look_back * 2) + 1:len(dataset) - 1, :] = testPredict

# Plot actual vs predicted prices
plt.figure(figsize=(12, 6))
plt.plot(df['last'], label='Actual')
plt.plot(pd.DataFrame(trainPredictPlot, columns=["close"], index=df.index).close, label='Training')
plt.plot(pd.DataFrame(testPredictPlot, columns=["close"], index=df.index).close, label='Testing')
plt.legend(loc='best')
plt.show()

# Use Solana data for this example
df = crypto_data['SOL1-USD'].to_frame()  # Change 'BTC-USD' to 'SOL1-USD'
df.reset_index(inplace=True)
df.columns = ['datetime', 'last']

# Normalize the data
dataset = df['last'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
dataset = scaler.fit_transform(dataset)

# Split the data into training and testing sets
train_size = int(len(dataset) * 0.67)
test_size = len(dataset) - train_size
train, test = dataset[0:train_size, :], dataset[train_size:len(dataset), :]

# Convert data to input-output pairs
def create_dataset(dataset, look_back=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back - 1):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

look_back = 10
trainX, trainY = create_dataset(train, look_back=look_back)
testX, testY = create_dataset(test, look_back=look_back)

# Reshape input to be [samples, time steps, features]
trainX = np.reshape(trainX, (trainX.shape[0], 1, trainX.shape[1]))
testX = np.reshape(testX, (testX.shape[0], 1, testX.shape[1]))

# Build and train the LSTM model
model = Sequential()
model.add(LSTM(4, input_shape=(1, look_back)))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(trainX, trainY, epochs=100, batch_size=256, verbose=2)

# Make predictions
trainPredict = model.predict(trainX)
testPredict = model.predict(testX)

# Invert predictions
trainPredict = scaler.inverse_transform(trainPredict)
trainY = scaler.inverse_transform([trainY])
testPredict = scaler.inverse_transform(testPredict)
testY = scaler.inverse_transform([testY])

# Calculate root mean squared error
trainScore = math.sqrt(mean_squared_error(trainY[0], trainPredict[:, 0]))
print('Train Score: %.2f RMSE' % trainScore)
testScore = math.sqrt(mean_squared_error(testY[0], testPredict[:, 0]))
print('Test Score: %.2f RMSE' % testScore)

# Shift train predictions for plotting
trainPredictPlot = np.empty_like(dataset)
trainPredictPlot[:, :] = np.nan
trainPredictPlot[look_back:len(trainPredict) + look_back, :] = trainPredict

# Shift test predictions for plotting
testPredictPlot = np.empty_like(dataset)
testPredictPlot[:, :] = np.nan
testPredictPlot[len(trainPredict) + (look_back * 2) + 1:len(dataset) - 1, :] = testPredict

# Plot actual vs predicted prices
plt.figure(figsize=(12, 6))
plt.plot(df['last'], label='Actual')
plt.plot(pd.DataFrame(trainPredictPlot, columns=["close"], index=df.index).close, label='Training')
plt.plot(pd.DataFrame(testPredictPlot, columns=["close"], index=df.index).close, label='Testing')
plt.legend(loc='best')
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from sklearn.impute import SimpleImputer

# Load data for Bitcoin, Ethereum, and Solana from Yahoo Finance
tickers = ['BTC-USD', 'ETH-USD', 'SOL1-USD']
start_date = '2017-06-28'
end_date = '2022-01-01'
crypto_data = yf.download(tickers, start=start_date, end=end_date)['Adj Close']

# Check for NaN values in the dataset
if crypto_data.isnull().values.any():
    print("Dataset contains NaN values. Check the data loading process.")
    # Drop rows with NaN values
    crypto_data.dropna(inplace=True)

# Normalize the data for each cryptocurrency
scalers = {}
datasets = {}
for ticker in tickers:
    df = crypto_data[ticker].to_frame()
    df.reset_index(inplace=True)
    df.columns = ['datetime', 'last']
    dataset = df['last'].values.reshape(-1, 1)
    scalers[ticker] = MinMaxScaler(feature_range=(0, 1))
    datasets[ticker] = scalers[ticker].fit_transform(dataset)

# Split the data into training and testing sets
train_size = int(len(datasets['BTC-USD']) * 0.67)
test_size = len(datasets['BTC-USD']) - train_size
train, test = {}, {}
for ticker in tickers:
    train[ticker], test[ticker] = datasets[ticker][0:train_size, :], datasets[ticker][train_size:len(datasets[ticker]), :]

# Convert data to input-output pairs
def create_dataset(dataset, look_back=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - look_back - 1):
        a = dataset[i:(i + look_back), 0]
        dataX.append(a)
        dataY.append(dataset[i + look_back, 0])
    return np.array(dataX), np.array(dataY)

look_back = 10
trainX, trainY, testX, testY = {}, {}, {}, {}
for ticker in tickers:
    trainX[ticker], trainY[ticker] = create_dataset(train[ticker], look_back=look_back)
    testX[ticker], testY[ticker] = create_dataset(test[ticker], look_back=look_back)

# Reshape input to be [samples, time steps, features]
trainX = {ticker: np.reshape(trainX[ticker], (trainX[ticker].shape[0], 1, trainX[ticker].shape[1])) for ticker in tickers}
testX = {ticker: np.reshape(testX[ticker], (testX[ticker].shape[0], 1, testX[ticker].shape[1])) for ticker in tickers}

# Build and train the LSTM model for each cryptocurrency
models = {}
for ticker in tickers:
    model = Sequential()
    model.add(LSTM(4, input_shape=(1, look_back)))
    model.add(Dense(1))
    model.compile(loss='mean_squared_error', optimizer='adam')
    model.fit(trainX[ticker], trainY[ticker], epochs=100, batch_size=256, verbose=2)
    models[ticker] = model

# Make predictions for each cryptocurrency
trainPredict, testPredict = {}, {}
for ticker in tickers:
    trainPredict[ticker] = models[ticker].predict(trainX[ticker])
    testPredict[ticker] = models[ticker].predict(testX[ticker])

# Invert predictions for each cryptocurrency
trainPredict = {ticker: scalers[ticker].inverse_transform(trainPredict[ticker]) for ticker in tickers}
trainY = {ticker: scalers[ticker].inverse_transform([trainY[ticker]])[0] for ticker in tickers}
testPredict = {ticker: scalers[ticker].inverse_transform(testPredict[ticker]) for ticker in tickers}
testY = {ticker: scalers[ticker].inverse_transform([testY[ticker]])[0] for ticker in tickers}

# Calculate root mean squared error for each cryptocurrency
trainScore = {ticker: math.sqrt(mean_squared_error(trainY[ticker], trainPredict[ticker][:, 0])) for ticker in tickers}
testScore = {ticker: math.sqrt(mean_squared_error(testY[ticker], testPredict[ticker][:, 0])) for ticker in tickers}
print('Train Score:', trainScore)
print('Test Score:', testScore)

# Plot actual vs predicted prices for each cryptocurrency
plt.figure(figsize=(12, 6))
for ticker in tickers:
    plt.plot(df['datetime'][:len(trainPredict[ticker])], trainPredict[ticker], label='Training Predictions ' + ticker)
    plt.plot(df['datetime'][len(trainPredict[ticker])+look_back+1:len(trainPredict[ticker])+look_back+1+len(testPredict[ticker])], testPredict[ticker], label='Testing Predictions ' + ticker)
    plt.plot(df['datetime'], datasets[ticker], label='Actual ' + ticker)
    plt.legend(loc='best')
    plt.title('Actual vs Predicted Prices for ' + ticker)
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.show()